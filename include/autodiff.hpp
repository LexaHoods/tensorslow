/*
* General automatic differentiation engine based on a Wengert list
* implementation. Reverse mode only.
*/

#pragma once

#include <vector>


namespace ts {
	template <typename T> class Node;
	template <typename T> class WengertList;
	template <typename T> class Var;
	template <typename T> class Gradient;


	// This helper function allows us to create Var instances without template
	// syntax. This way, the type will be the same as its parent WengertList.
	template <typename T>
	ts::Var<T> NewVar(T newValue, ts::WengertList<T> * newWList);


	template <typename T>
	ts::Var<T> operator+(const ts::Var<T> &x, const ts::Var<T> &y);
	template <typename T>
	ts::Var<T> operator-(const ts::Var<T> &x, const ts::Var<T> &y);
	template <typename T>
	ts::Var<T> operator*(const ts::Var<T> &x, const ts::Var<T> &y);
	template <typename T>
	ts::Var<T> operator/(const ts::Var<T> &x, const ts::Var<T> &y);
}



template <typename T>
class ts::Node {
private:
	// Represents an input variable
	Node();

	// Represents a unary operator
	Node(T xVal, int xDep);

	// Represents a binary operator
	Node(T xVal, int xDep, T yVal, int yDep);


	std::vector<T> values{};
	std::vector<int> dependencies{};

public:

	friend ts::Var<T>;

	friend ts::Var<T> operator+<>(const ts::Var<T> &x, const ts::Var<T> &y);
	friend ts::Var<T> operator-<>(const ts::Var<T> &x, const ts::Var<T> &y);
	friend ts::Var<T> operator*<>(const ts::Var<T> &x, const ts::Var<T> &y);
	friend ts::Var<T> operator/<>(const ts::Var<T> &x, const ts::Var<T> &y);
};



template <typename T>
class ts::WengertList {
private:
	std::vector<ts::Node<T>> nodes{};

public:
	int size();

	friend class ts::Var<T>;
};



template <typename T>
class ts::Var {
private:
	T value;
	ts::WengertList<T> * wList;
	int index;

	// We want this constructor to be private as it is supposed to be called by
	// our friends overloaded operators and functions only. This constructor
	// thus allows us to create a Var with dependencies in the Wengert list.
	Var(T newValue, ts::WengertList<T> * newWList, ts::Node<T> node);

public:
	Var(T newValue, ts::WengertList<T> * wList);

	T getValue();
	ts::Gradient<T> grad();

	friend ts::Gradient<T>;

	friend ts::Var<T> operator+<>(const ts::Var<T> &x, const ts::Var<T> &y);
	friend ts::Var<T> operator-<>(const ts::Var<T> &x, const ts::Var<T> &y);
	friend ts::Var<T> operator*<>(const ts::Var<T> &x, const ts::Var<T> &y);
	friend ts::Var<T> operator/<>(const ts::Var<T> &x, const ts::Var<T> &y);
};



template <typename T>
class ts::Gradient {
private:
	// Constructor is private since we want instances of this class to be
	// generated by the Var::grad() method only
	Gradient(std::vector<T> newDerivatives);

	std::vector<T> derivatives;

public:
	T getValue(ts::Var<T> a);

	friend class ts::Var<T>;
};
