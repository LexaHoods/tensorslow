/*
* General automatic differentiation engine based on a Wengert list
* implementation. Reverse mode only.
*/

#pragma once

#include <vector>


namespace ts {
	class Node;
	class WengertList;
	class Var;
	class Gradient;

	ts::Var operator+(const ts::Var &x, const ts::Var &y);
	ts::Var operator-(const ts::Var &x, const ts::Var &y);
	ts::Var operator*(const ts::Var &x, const ts::Var &y);
	ts::Var operator/(const ts::Var &x, const ts::Var &y);
}



class ts::Node {
private:
	std::vector<float> values{};
	std::vector<int> dependencies{};

public:

	// Represents an input variable
	Node();

	// Represents a unary operator
	Node(float xVal, int xDep);

	// Represents a binary operator
	Node(float xVal, int xDep, float yVal, int yDep);

	friend ts::Var;
};



class ts::WengertList {
private:
	std::vector<ts::Node> nodes{};

public:
	int size();

	friend class ts::Var;
};



class ts::Var {
private:
	float value;
	ts::WengertList * wList;
	int index;

	// We want this constructor to be private as it is supposed to be called by
	// our friends overloaded operators and functions only. This constructor
	// thus allows us to create a Var with dependencies in the Wengert list.
	Var(float newValue, ts::WengertList * newWList, ts::Node node);

public:
	Var(float newValue, ts::WengertList * wList);

	float getValue();
	ts::Gradient grad();

	friend ts::Gradient;

	friend ts::Var operator+(const ts::Var &x, const ts::Var &y);
	friend ts::Var operator-(const ts::Var &x, const ts::Var &y);
	friend ts::Var operator*(const ts::Var &x, const ts::Var &y);
	friend ts::Var operator/(const ts::Var &x, const ts::Var &y);
};



class ts::Gradient {
private:
	// Constructor is private since we want instances of this class to be
	// generated by the WengertList::grad() method only
	Gradient(std::vector<float> newDerivatives);

	std::vector<float> derivatives;

public:
	float getValue(ts::Var a);

	friend class ts::Var;
};
